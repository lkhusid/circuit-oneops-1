# A utility module to deal with cassandra storage
# config YAML and other helper methods.
#
# Cookbook Name:: cassandra
# Library:: cassandra_util
#
# Copyright 2015, @WalmartLabs.

module Cassandra

  module Util
    require 'json'
    require 'yaml'

    include Chef::Mixin::ShellOut

    # Checks if the YAML config directives are supported.
    # Applicable only if versions of Cassandra >= 1.2 and
    # has a non empty config directive map.
    #
    def conf_directive_supported?
      if node.workorder.has_key?("rfcCi")
      	ci = node.workorder.rfcCi.ciAttributes
      else
      	ci = node.workorder.ci.ciAttributes
      end
      ver = ci.version.to_f
      cfg = ci.config_directives if ci.has_key?("config_directives")
      cassandra_supported?(ver) && !cfg.nil? && !cfg.empty?
    end

    # Merge cassandra config directives to the given Cassandra
    # storage config YAML file. The method will error out if
    # it couldn't find the yaml config file.
    #
    # Note : Right now there is no way to preserve the comments in
    # YAML when you do the modification using libraries. Normally
    # this method call would be guarded by ::conf_directive_supported?
    #
    #  Eg:  merge_conf_directives(file, cfg) if conf_directive_supported?
    #
    # @param  config_file:: cassandra yaml config file
    # @param  cfg:: Configuration directives map.
    #
    def merge_conf_directives(config_file, cfg)
      Chef::Log.info "YAML config file: #{config_file}, conf directive entries: #{cfg}"
      yaml = YAML::load_file(config_file)
      cfg.each_key { |key|
        val = parse_json(cfg[key])
        yaml[key] = val
      }
      Chef::Log.info "Merged cassandra YAML config: #{yaml.to_yaml}"

      File.open(config_file, 'w') { |f|
        f.write <<-EOF
# Cassandra storage config YAML
#
# NOTE:
#   See http://wiki.apache.org/cassandra/StorageConfiguration
#   for explanations of configuration directives
# /NOTE
#
# Auto generated by Cassandra cookbook
        EOF
        f.write yaml.to_yaml
        Chef::Log.info "Saved YAML config to #{config_file}"
      }
    end

    # Checks if the cassandra version is
    # supported for YAML config directives.
    #
    # @param ver:: cassandra version
    #
    def cassandra_supported?(ver)
      ver >= 1.2
    end


    # Checks whether the given string is a valid json or not.
    #
    # @param json:: input json string
    #
    def valid_json?(json)
      begin
        JSON.parse(json)
        return true
      rescue Exception => e
        return false
      end
    end

    # Returns the parsed json object if the input string is a valid json, else
    # returns the input by doing the type conversion. Currently boolean, float,
    # int and string types are supported. The type conversion is required for
    # yaml since the input from UI would always be string.
    #
    # @param json:: input json string
    #
    def parse_json (json)
      begin
        return json if json.class == Hash
        return json if json.class == Array
        return JSON.parse(json)
      rescue Exception => e
        # Assuming it would be string.
        # Boolean type
        return true if  json =~ (/^(true)$/i)
        return false if  json =~ (/^(false)$/i)
        # Fixnum type
        return json.to_i if  (json.to_i.to_s == json)
        # Float type
        return json.to_f if  (json.to_f.to_s == json)
        return json
      end
    end
    
    def update_found
        old_vals = node.workorder.rfcCi.ciBaseAttributes
        new_vals = node.workorder.rfcCi.ciAttributes
        new_vals.keys.each do |k|
          if old_vals.has_key?(k) && 
             old_vals[k] != new_vals[k]
             Chef::Log.info("changed: old #{k}:#{old_vals[k]} != new #{k}:#{new_vals[k]}")
             return true
          end
        end
        return false
    end
    
    def update_found_dependOn
      depends_on = node.workorder.payLoad.DependsOn
      depends_on.each do |d|
        old_vals = d.ciBaseAttributes
        new_vals = d.ciAttributes
        new_vals.keys.each do |k|
          if old_vals.has_key?(k) && 
             old_vals[k] != new_vals[k]
             Chef::Log.info("changed: old #{k}:#{old_vals[k]} != new #{k}:#{new_vals[k]}")
             return true
          end
        end
      end
      return false
    end
    
    def self.find_seeds(node, ip_exclude)
      if node.workorder.has_key?("rfcCi")
        ci = node.workorder.rfcCi
      else
        ci = node.workorder.ci
      end
      cfg = JSON.parse(ci.ciAttributes.config_directives)

      computes = node.workorder.payLoad.has_key?("RequiresComputes") ? node.workorder.payLoad.RequiresComputes : node.workorder.payLoad.computes
      return [computes.first["ciAttributes"]["private_ip"]] if (computes.size == 1)
      cloud_computes = {}
      computes.each do |compute|
        next if compute[:ciAttributes][:private_ip].nil? || compute[:ciAttributes][:private_ip].empty?
        next if compute[:ciAttributes][:private_ip] == ip_exclude
        cloud_id = compute[:ciName].split('-').reverse[1]
        computeList = cloud_computes[cloud_id]
        if computeList == nil
          computeList = []
        end
        computeList.push compute
        cloud_computes[cloud_id] = computeList
      end
      seeds = cfg.key?('seeds') ? [cfg['seeds']] : []
      cloud_computes.each do |key, value|
        puts "cloud = "+key
        value.each do |c|
          puts c[:ciName] + " : "+c["ciAttributes"]["private_ip"]
        end
        sorted_computes = value.sort_by {|obj| obj.ciName}
        if value.size > 2
          slected_computes = sorted_computes.first(2)
        else
          slected_computes = sorted_computes.first(1)
        end
        slected_computes.each do |s|
          seeds.push s["ciAttributes"]["private_ip"]
        end
      end
      puts "seeds = #{seeds.join(',')}"
      return seeds
    end

    #Check if the cassandra is running, allow #seconds to start running
    def cassandra_running(seconds=120)
      begin
        Timeout::timeout(seconds) do
          running = false
          while !running do
            cmd = "service cassandra status 2>&1"
            Chef::Log.info(cmd)
            result  = `#{cmd}`
            if $? == 0
              running = true
              break
            end
            sleep 5
          end
          return running
        end
      rescue Timeout::Error 
        return false
      end
    end
 
    def port_open?(ip, port)
      begin
        cmd = "service cassandra status 2>&1"
        result  = `#{cmd}`
        if $? == 0
          Chef::Log.info("Check if port #{port} open on #{ip}")
          TCPSocket.new(ip, port).close
          return true
        else
          puts "***FAULT:FATAL=Cassandra isn't running on #{ip}"
          e = Exception.new("no backtrace")
          e.set_backtrace("")
          raise e         
        end
      rescue Errno::ECONNREFUSED, Errno::EHOSTUNREACH, SocketError
        sleep 5
        retry
      end
    end
    
  def self.default_dc_rack_mapping(node)
    dc_rack_map = {}
    cloud_map = {} 
    node.workorder.payLoad.clouds.each do |c|
      key = c['ciId'].to_s
      cloud_map[key] = c
    end
    node.workorder.payLoad.computes.each do |c| 
      ci_name_parts = c['ciName'].split("-")
      cloud_ci_id = ci_name_parts[-2] 
      cloud_name = cloud_map[cloud_ci_id]['ciName']
      dc_rack_map[cloud_name] = "#{cloud_name}:RAC1"
    end
    return dc_rack_map
  end

  def cluster_normal?(node)
    yaml_file = '/etc/cassandra/cassandra.yaml'
    nodetool = "nodetool"
    if node.platform =~ /redhat|centos/
      yaml_file = "/opt/cassandra/conf/cassandra.yaml" 
      nodetool = "/opt/cassandra/bin/nodetool"
    end
    yaml = YAML::load_file(yaml_file)
    seeds = yaml['seed_provider'][0]['parameters'][0]['seeds'].split(',')
    rows = `#{nodetool} -h #{seeds[0]} status`.split("\n")
    Chef::Log.info("ring rows: #{rows.inspect}")
    rows.each do |row|
      Chef::Log.info("row: #{row}")
      parts = row.split(" ")
      next unless parts.size == 8  
      next unless IPAddress.valid? parts[1] 
      if parts[0] !~ /UN|DN/ then
          Chef::Log.info("Node #{parts[1]} is in #{parts[0]} state")
          return false
      end
    end
    return true
  end

  def self.new_cluster?(node)
    computes = node.workorder.payLoad.has_key?("RequiresComputes") ? node.workorder.payLoad.RequiresComputes : node.workorder.payLoad.computes
    added_computes = []
    computes.each do |compute|
      next if !compute.has_key?"rfcAction" || compute[:rfcAction] != 'add'
      added_computes.push compute
    end
    return computes.size == added_computes.size
  end

  def self.sorted_ci_names(node, action)
     computes = node.workorder.payLoad.has_key?("RequiresComputes") ? node.workorder.payLoad.RequiresComputes : node.workorder.payLoad.computes
     ci_cloud_ids = []
     computes.each do |compute|
       next if !compute.has_key?"rfcAction" || compute[:rfcAction] != action
       ci_cloud_ids.push compute[:ciName].split('-',2)[1]
     end
     return ci_cloud_ids.sort! { |x,y| (y.split('-')[1] == x.split('-')[1]) ? y.split('-')[0].to_i <=> x.split('-')[0].to_i : y.split('-')[1].to_i <=> x.split('-')[1].to_i }.reverse
  end

  # This method returns the port no used by the cqlsh to connect to
  def get_def_cqlsh_port()
      cassandra_home = node.default[:cassandra_home]
      cassandra_current = "#{cassandra_home}/current"
      yaml_file = "#{cassandra_current}/conf/cassandra.yaml"

      if node.workorder.has_key?("rfcCi")
        ci = node.workorder.rfcCi.ciAttributes
      else
        ci = node.workorder.ci.ciAttributes
      end

      ver = ci.version.to_f
      yaml = YAML::load_file(yaml_file)

      if ver >=  2.1
        port = yaml['native_transport_port']
      else
        port = yaml['rpc_port']
      end
      return port
  end

  def self.cassandra_version(node)
    if node.workorder.has_key?("rfcCi")
      ci = node.workorder.rfcCi.ciAttributes
    else
      ci = node.workorder.ci.ciAttributes
    end
    return ci['version'].to_f  #Safely converts anything starting with n.n to a float.
  end

  # Runs nodetool info and returns a hash of the properties returned by the command.
  # For example nodetool_info()['ID'] = '381aed23-ebc5-4366-b762-7624cb862d1d'
  # Returns nil if the command fails.
  def self.nodetool_info()
    out = `/opt/cassandra/bin/nodetool info`
    if $? == 0
      props = {}
      out.split("\n").each do |line|
        p = line.split(':')
        props[p.first.strip] = p.last.strip
      end
      return props
    else
      Chef::Log.warn("nodetool info failed with #{out}")
      return nil
    end
  end

  # Estimate the time when the node was last up.
  # This can be used if Jolokia isn't running.'
  # Alternatively, check mtime on log files & commit logs.
  def self.last_activity_time()
    yaml = YAML::load_file('/opt/cassandra/conf/cassandra.yaml')
    files = Dir.glob("#{yaml['commitlog_directory']}/*.log")
    time = Time.at(0)
    files.each do |f|
      next unless File.file?(f)
      time = [time, File.mtime(f)].max
    end
    return time
  end

  #Query how long a given node has been down.
  #This is obtained from the Gossiper MBean via the Jolokia proxy on a seed node that's up.
  def self.get_node_downtime_ms(address, node)
    body = {
      'type' => 'EXEC', 'mbean' => 'org.apache.cassandra.net:type=Gossiper', 'operation' => 'getEndpointDowntime', 
      'arguments' => [address],
      'target' => {'url' => 'service:jmx:rmi:///jndi/rmi://localhost:7199/jmxrmi'}
    }
    yaml = YAML::load_file('/opt/cassandra/conf/cassandra.yaml')
    yaml['seed_provider'][0]['parameters'][0]['seeds'].split(',').each do |ip|
      uri = URI("http://#{ip}:17330/jolokia/")
      Chef::Log.info("Querying Jolokia on seed node #{ip} for downtime of #{address}")
      request = Net::HTTP::Post.new(uri.path)
      request.body = body.to_json
      Chef::Log.info("Request body is #{request.body}")
      http = Net::HTTP.new(uri.host, uri.port)
      res = http.request(request)
      #Jolokia will return a 200 even on errors.  The JSON response (status & error properties) must be parsed & inspected for errors.
      case res
      when Net::HTTPSuccess
        jolokia_response = JSON.parse(res.body)
        Chef::Log.info("jolokia response #{jolokia_response.inspect}")
        if jolokia_response['status'] == 200
          return jolokia_response['value'].to_i
        else
          Chef::Log.info("Jolokia request to #{uri} failed with Jolokia error #{jolokia_response['status']}, #{jolokia_response['error']}.\n#{res.body}")
        end
      else
        Chef::Log.info("Jolokia request to #{uri} failed with HTTP error #{res.value}")
      end
    end
    raise 'Could not contact a seed node to determine node downtime'
  end

  #Determine the minimum gc_grace_seconds (greater than zero) from all tables.
  def self.min_gc_grace(node)
    table = 'system_schema.tables'
    if cassandra_version(node) <= 2.1
      table = 'system.schema_columnfamilies'
    end
    ci = node.workorder.has_key?("rfcCi")?node.workorder.rfcCi : node.workorder.ci
    if ci.ciAttributes[:auth_enabled].eql?("true")
      auth = "-u #{ci.ciAttributes[:username]} -p \"#{ci.ciAttributes[:password]}\""
    end
    yaml = YAML::load_file('/opt/cassandra/conf/cassandra.yaml')
    yaml['seed_provider'][0]['parameters'][0]['seeds'].split(',').each do |ip|
      cmd = "/opt/cassandra/bin/cqlsh --no-color -e 'CONSISTENCY ONE; SELECT gc_grace_seconds FROM #{table}' #{auth} #{ip} | grep -o '[0-9]*\$' | awk '\$1>0{print \$1}' | sort -n | head -1"
      Chef::Log.info("Running #{cmd}")
      r = `#{cmd}`
      Chef::Log.info("min gc grace command returned #{r}")
      return r.to_i if $? == 0 && r.length > 0
    end
    Chef::Log.warn('Could not determine minimum GC grace period by querying seed nodes, using default of 7 days')
    return 604800
  end

  # Run nodetool status and return the output as a hash of hashes.
  # ex: puts nodetool_status()['1.1.1.1'][:load]
  # 4.86 GB
  def nodetool_status()
    out = `/opt/cassandra/bin/nodetool status`
    raise 'nodetool status failed' if $? != 0
    rows = out.split("\n")
    hash = {}
    dc_exp = /Datacenter: (.*)/
    #vnode
    #--  Address         Load       Tokens  Owns    Host ID                               Rack
    #non-vnode
    #--  Address         Load       Owns    Host ID                               Token               Rack
    #node_ex = /^(?<status>[UD\?][NLJM]) +(?<address>(?:[0-9]{1,3}\.){3}[0-9]{1,3}) +(?<load>(\d+\.?\d* (TB|GB|MB|KB|bytes))|\?) +(?<tokens>\d+) +(?<owns>(\d+\.?\d*%|\?)) +(?<hostid>[a-z0-9\-]+) +(?<rack>.*)$/
    node_ex = /^([UD\?][NLJM]) +((?:[0-9]{1,3}\.){3}[0-9]{1,3}) +((?:\d+\.?\d* (?:TB|GB|MB|KB|bytes))|\?) +(\d+) +(\d+\.?\d*%|\?) +([a-z0-9\-]+) +(.*)$/
    datacenter = nil
    rows.each do |row|
      m = dc_exp.match(row)
      if m
        datacenter = m[1]
        next
      end
      m = node_ex.match(row)
      next if m == nil
      node = {'datacenter' => datacenter}
      hash[m[2]] = node
      i = 0
      %w(status address load tokens owns hostid rack).each do |name|
        node[name] = m[i += 1]
      end
      # m.names.each do |name|
      #   node[name] = m[name]
      # end
    end
    return hash
  end

  # Parse "n KB|MB|GB|TB|bytes" into the number of bytes
  # Un-does FileUtils.stringifyFileSize
  def self.load_to_bytes(load)
    m = /([\d,.]+)? (bytes|KB|MB|GB|TiB|TB)/.match(load)
    return 0 if m == nil
    n = m[1].to_f
    f = 1
    f = 1024 if m[2] == 'KB'
    f = 1024 * 1024 if m[2] == 'MB'
    f = 1024 * 1024 * 1024 if m[2] == 'GB'
    f = 1024 * 1024 * 1024 * 1024 if m[2] == 'TiB' || m[2] == 'TB'
    return n * f
  end

  def self.isAzure() 
    has_waagent? || has_dhcp_option_245?
  end

  def self.has_waagent?
    if File.exist?("/usr/sbin/waagent")
      Chef::Log.info("waagent is present, must be Azure")
      true
    end
  end

  def self.has_dhcp_option_245?
    has_245 = false
    if File.exist?("/var/lib/dhcp/dhclient.eth0.leases")
      File.open("/var/lib/dhcp/dhclient.eth0.leases").each do |line|
        if line =~ /unknown-245/
          Chef::Log.info("Found unknown-245 DHCP option, must be Azure.")
          has_245 = true
          break
        end
      end
    end
    has_245
  end

  def self.fetch_azure_metadata()
    conn = Net::HTTP.start('169.254.169.254')
    conn.read_timeout = 10
    response = conn.get('/metadata/instance?api-version=2017-04-02', initheader = { "Metadata" => "true" })
    if response.code == "200"
      begin
        json = JSON.parse(response.body)
      rescue Exception => e
        Chef::Log.error("Unparseable response from Azure Metadata service: #{e}")
        nil
      end
    else
      Chef::Log.error("Azure Metadata service failed with response code #{response.code}")
      nil
    end
  end

  def node_joining(ip)
    result = `/opt/cassandra/bin/nodetool -h #{ip} netstats | grep Mode`
    if $? != 0
        Chef::Log.error("nodetool command on #{ip} failed")
        puts "***FAULT:FATAL=nodetool command failed"
        e = Exception.new("no backtrace")
        e.set_backtrace("")
        raise e
    end
    return result =~ /JOINING/
  end

  def receiving_streams(ip)
      result = `/opt/cassandra/bin/nodetool -h #{ip} netstats | grep 'Receiving .* files' | wc -l`
      if $? != 0
          Chef::Log.error("nodetool command on #{ip} failed")
          puts "***FAULT:FATAL=nodetool command failed"
          e = Exception.new("no backtrace")
          e.set_backtrace("")
          raise e
      end
      return result.to_i > 0
  end

    # Runs nodetool info and returns a hash of the properties returned by the command.
  # For example nodetool_info()['ID'] = '381aed23-ebc5-4366-b762-7624cb862d1d'
  # Returns nil if the command fails.
  def nodetool_info()
    out = `/opt/cassandra/bin/nodetool info`
    if $? == 0
      props = {}
      out.split("\n").each do |line|
        p = line.split(':')
        props[p.first.strip] = p.last.strip
      end
      return props
    else
      Chef::Log.warn("nodetool info failed with #{out}")
      return nil
    end
  end

  end
end
